<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Rust Tooling in Modern JavaScript</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <!-- Reveal.js via CDN to keep setup simple -->
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/reveal.js@5.1.0/dist/reveal.css"
    />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/reveal.js@5.1.0/dist/theme/white.css"
      id="theme"
    />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/reveal.js@5.1.0/plugin/highlight/monokai.css"
    />

    <style>
      body {
        background: radial-gradient(circle at top left, #4fd1ff 0, #0b1724 40%, #200016 100%);
      }

      .reveal {
        color: #f5f5f5;
      }

      .reveal section h1,
      .reveal section h2,
      .reveal section h3 {
        text-transform: none;
        letter-spacing: 0.03em;
      }

      .reveal section h1 {
        color: #ff4b6a;
        text-shadow: 0 0 18px rgba(255, 75, 106, 0.5);
      }

      .reveal section h2,
      .reveal section h3 {
        color: #4fd1ff;
        text-shadow: 0 0 14px rgba(79, 209, 255, 0.4);
      }

      .reveal p,
      .reveal li {
        color: #0a3d5f;
      }

      .reveal a {
        color: #ff4b6a;
      }

      .reveal img {
        filter: drop-shadow(0 6px 18px rgba(0, 0, 0, 0.6));
      }

      .hero-blackhole {
        position: relative;
        width: 100%;
        max-width: 900px;
        height: 380px;
        margin: 2.5rem auto 0;
      }

      .code-row {
        display: flex;
        gap: 1.5rem;
        justify-content: center;
        align-items: flex-start;
        margin-bottom: 1.2rem;
      }

      .code-row pre {
        flex: 1 1 0;
      }

      .tool-heading {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 1rem;
        margin-bottom: 1rem;
      }


      .reveal pre {
        box-shadow: 0 14px 35px rgba(0, 0, 0, 0.55);
        border-radius: 14px;
        overflow: hidden;
        background: #050b16;
        max-width: 80%;
        margin: 1rem auto;
      }

      .reveal pre code {
        font-size: 0.8em;
        line-height: 1.5;
        text-shadow: none;
        padding: 1rem 1.25rem;
        display: block;
      }

      .tooling-line {
        font-size: 1.05rem;
        margin: 0.6rem 0;
        color: #0a3d5f;
      }

      .tooling-kind {
        color: #ff4b6a;
        font-weight: 600;
      }

      .hero-blackhole-core {
        position: absolute;
        top: 50%;
        left: 50%;
        width: 220px;
        height: 220px;
        border-radius: 50%;
        transform: translate(-50%, -50%);
        background: radial-gradient(circle, #000 0, #050518 35%, rgba(0, 0, 0, 0) 75%);
        box-shadow:
          0 0 40px rgba(0, 0, 0, 0.9),
          0 0 80px rgba(79, 209, 255, 0.8),
          0 0 120px rgba(255, 75, 106, 0.6);
      }

      .hero-logo {
        position: absolute;
        width: 80px;
        height: auto;
        top: 50%;
        left: 50%;
        transform-origin: center center;
      }

      .hero-logo--swc {
        animation: hero-orbit-swc 38s linear infinite;
      }

      .hero-logo--babel {
        animation: hero-orbit-babel 26s linear infinite reverse;
      }

      .hero-logo--webpack {
        animation: hero-orbit-webpack 44s linear infinite;
      }

      .hero-logo--rollup {
        animation: hero-orbit-rollup 32s linear infinite reverse;
      }

      .hero-logo--vite {
        animation: hero-orbit-vite 30s linear infinite;
      }

      .hero-logo--turbo {
        animation: hero-orbit-turbo 52s linear infinite reverse;
      }

      .hero-logo--rolldown {
        animation: hero-orbit-rolldown 48s linear infinite;
      }

      .hero-logo--oxc {
        animation: hero-orbit-oxc 34s linear infinite reverse;
      }

      .hero-logo--biome {
        animation: hero-orbit-biome 40s linear infinite;
      }

      @keyframes hero-orbit-swc {
        from {
          transform: translate(-50%, -50%) rotate(0deg) translateX(320px);
        }
        to {
          transform: translate(-50%, -50%) rotate(360deg) translateX(320px);
        }
      }

      @keyframes hero-orbit-babel {
        from {
          transform: translate(-50%, -50%) rotate(0deg) translateX(260px);
        }
        to {
          transform: translate(-50%, -50%) rotate(360deg) translateX(260px);
        }
      }

      @keyframes hero-orbit-webpack {
        from {
          transform: translate(-50%, -50%) rotate(0deg) translateX(360px);
        }
        to {
          transform: translate(-50%, -50%) rotate(360deg) translateX(360px);
        }
      }

      @keyframes hero-orbit-rollup {
        from {
          transform: translate(-50%, -50%) rotate(0deg) translateX(220px);
        }
        to {
          transform: translate(-50%, -50%) rotate(360deg) translateX(220px);
        }
      }

      @keyframes hero-orbit-vite {
        from {
          transform: translate(-50%, -50%) rotate(0deg) translateX(280px);
        }
        to {
          transform: translate(-50%, -50%) rotate(360deg) translateX(280px);
        }
      }

      @keyframes hero-orbit-turbo {
        from {
          transform: translate(-50%, -50%) rotate(0deg) translateX(340px);
        }
        to {
          transform: translate(-50%, -50%) rotate(360deg) translateX(340px);
        }
      }

      @keyframes hero-orbit-rolldown {
        from {
          transform: translate(-50%, -50%) rotate(0deg) translateX(240px);
        }
        to {
          transform: translate(-50%, -50%) rotate(360deg) translateX(240px);
        }
      }

      @keyframes hero-orbit-oxc {
        from {
          transform: translate(-50%, -50%) rotate(0deg) translateX(200px);
        }
        to {
          transform: translate(-50%, -50%) rotate(360deg) translateX(200px);
        }
      }

      @keyframes hero-orbit-biome {
        from {
          transform: translate(-50%, -50%) rotate(0deg) translateX(260px);
        }
        to {
          transform: translate(-50%, -50%) rotate(360deg) translateX(260px);
        }
      }

      @media (max-width: 768px) {
        .hero-blackhole {
          height: 260px;
        }

        .hero-blackhole-core {
          width: 160px;
          height: 160px;
        }

        .hero-logo {
          width: 56px;
        }
      }
    </style>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <!-- 1. Intro -->
        <section>
          <div class="hero-blackhole">
            <div class="hero-blackhole-core"></div>
            <img
              class="hero-logo hero-logo--swc"
              src="https://swc.rs/logo.png"
              alt="SWC logo"
            />
            <img
              class="hero-logo hero-logo--babel"
              src="https://babeljs.io/img/babel.svg"
              alt="Babel logo"
            />
            <img
              class="hero-logo hero-logo--webpack"
              src="https://webpack.js.org/site-logo.c0e60df418e04f58.svg"
              alt="Webpack logo"
            />
            <img
              class="hero-logo hero-logo--rollup"
              src="https://rollupjs.org/rollup-logo.svg"
              alt="Rollup logo"
            />
            <img
              class="hero-logo hero-logo--vite"
              src="https://vitejs.dev/logo.svg"
              alt="Vite logo"
            />
            <img
              class="hero-logo hero-logo--turbo"
              src="https://turborepo.com/images/docs/repo/repo-hero-logo-dark.svg"
              alt="Turborepo logo"
            />
            <img
              class="hero-logo hero-logo--rolldown"
              src="https://rolldown.rs/rolldown-round.svg"
              alt="Rolldown logo"
            />
            <img
              class="hero-logo hero-logo--oxc"
              src="https://cdn.jsdelivr.net/gh/oxc-project/oxc-assets/round.svg"
              alt="Oxc logo"
            />
            <img
              class="hero-logo hero-logo--biome"
              src="https://biomejs.dev/_astro/logo-dark-transparent.Bwi2A1en.svg"
              alt="Biome logo"
            />
          </div>
        </section>

        <!-- 2. Title -->
        <section>
          <h1>Oxidize JavaScript Toolchain</h1>
        </section>

        <!-- 3. What is tooling? -->
        <section>
          <section>
            <h2>What Do We Mean by “Tooling”?</h2>
            <p class="tooling-line">
              <span class="tooling-kind">Transpilers</span> reshape source code to run on specific runtimes or browsers.
            </p>
            <p class="tooling-line">
              <span class="tooling-kind">Bundlers</span> stitch many modules and assets into a few deployable bundles.
            </p>
            <p class="tooling-line">
              <span class="tooling-kind">Linters</span> enforce correctness, catch bugs, and guide best practices.
            </p>
            <p class="tooling-line">
              <span class="tooling-kind">Formatters</span> keep code visually consistent and easy to read.
            </p>
          </section>
          <section>
            <h3>Transpilers: Modern JS to Compatible JS</h3>
            <p>From ESNext/TS/JSX to browser-compatible JavaScript.</p>
<pre><code class="language-javascript" data-trim>
// Source (ESNext)
const greeting = `Hello, ${user.name ?? "friend"}!`;
</code></pre>
<pre><code class="language-javascript" data-trim>
// Output (ES5-ish, simplified)
var name = user && user.name ? user.name : "friend";
var greeting = "Hello, " + name + "!";
</code></pre>
          </section>
          <section>
            <h3>Transpilers: JSX to JavaScript</h3>
            <p>Turn JSX syntax into plain JavaScript function calls.</p>
<pre><code class="language-javascript" data-trim>
// Source (JSX)
function Button() {
  return &lt;button className="primary"&gt;Click me&lt;/button&gt;;
}
</code></pre>
<pre><code class="language-javascript" data-trim>
// Output (JavaScript)
function Button() {
  return React.createElement(
    "button",
    { className: "primary" },
    "Click me",
  );
}
</code></pre>
            <p style="margin-top: 1.2rem; font-size: 0.9em;">
              Live demo idea: try a Rust-based transpiler playground such as
              <a href="https://swc.rs/playground" target="_blank" rel="noreferrer">swc.rs/playground</a>.
            </p>
          </section>
          <section>
            <h3>Bundlers: Bundle for the Browser</h3>
            <p>Take multiple modules and ship a single browser-ready bundle.</p>
            <div class="code-row">
<pre><code class="language-javascript" data-trim>
// src/index.js
import { add } from "./math.js";

console.log(add(1, 2));
</code></pre>
<pre><code class="language-javascript" data-trim>
// src/math.js
export function add(a, b) {
  return a + b;
}
</code></pre>
            </div>
<pre><code class="language-javascript" data-trim>
// dist/main.js (simplified bundle)
(function () {
  function add(a, b) {
    return a + b;
  }

  console.log(add(1, 2));
})();
</code></pre>
          </section>
          <section>
            <h3>Bundlers: Resolve Node-style Imports</h3>
            <p>Turn <code>import</code> from packages into code the browser can actually run.</p>
<pre><code class="language-javascript" data-trim>
// src/index.js (what you write)
import _ from "lodash";

console.log(_.camelCase("hello world"));
</code></pre>
<pre><code class="language-javascript" data-trim>
// dist/bundle.js (highly simplified)
(function (modules) {
  function __webpack_require__(id) {
    const module = { exports: {} };
    modules[id](module, module.exports, __webpack_require__);
    return module.exports;
  }

  __webpack_require__("./src/index.js");
})({
  "./src/index.js"(module, exports, __webpack_require__) {
    const _ = __webpack_require__(
      "./node_modules/lodash/lodash.js",
    );

    console.log(_.camelCase("hello world"));
  },

  "./node_modules/lodash/lodash.js"(module, exports) {
    // lodash implementation here...
  },
});
</code></pre>
          </section>
          <section>
            <h3>Linters: Catch Bugs Early</h3>
            <p>Static checks that prevent common mistakes.</p>
<pre><code class="language-javascript" data-trim>
// Before (ESLint screaming)
function greet(name) {
  message = "Hi " + name;     // ESLint: 'message' is not defined
  if (name == "admin") {      // ESLint: Expected '===' and strict equality
    console.log("Welcome");   // ESLint: Unexpected console statement
  }                           //        (no-console rule)
}
</code></pre>
<pre><code class="language-javascript" data-trim>
// After (ESLint fixes)
function greet(name) {
  const message = `Hi ${name}`;
  if (name === "admin") {
    console.log("Welcome back!");
  }
  return message;
}
</code></pre>
          </section>
          <section>
            <h3>Formatters: Make Code Consistent</h3>
            <p>Automatic formatting so style debates disappear.</p>
<pre><code class="language-javascript" data-trim>
// Before
const query={limit:10,offset:0, filters:[ "rust","tooling" ] }
function load(){return fetch("/api/search",{
method:"POST",body:JSON.stringify(query)})}
</code></pre>
<pre><code class="language-javascript" data-trim>
// After (formatted)
const query = {
  limit: 10,
  offset: 0,
  filters: ["rust", "tooling"],
};

function load() {
  return fetch("/api/search", {
    method: "POST",
    body: JSON.stringify(query),
  });
}
</code></pre>
          </section>
        </section>

        <!-- 4. Why Rust tooling -->
        <section>
          <section>
            <h2>Why Do We Need Rust Tooling?</h2>
          </section>
          <section>
            <h2>Why Do We Need Rust Tooling?</h2>
            <img
              src="./rewrite-everything-in-rust.png"
              alt="Rewrite it in Rust bell-curve meme"
              style="max-width: 380px; height: auto; margin: 2rem auto 0;"
            />
            <p style="margin-top: 1.2rem; font-size: 0.9em; opacity: 0.9;">
              Let&apos;s just rewrite everything in Rust!
            </p>
          </section>
          <section>
            <h2>Why Do We Actually Need Rust Tooling?</h2>
            <ul>
              <li>Faster.</li>
              <li class="fragment">Both development time for better developer experience and cheaper CI cost.</li>
              <li class="fragment">Old tools can&apos;t keep up with today&apos;s scale and needs.</li>
            </ul>
          </section>
        </section>

        <!-- 5. Old World: JS-written tooling -->
        <section>
          <section>
            <h2>The Old World: JS Tooling</h2>
            <ul>
              <li>Babel, Webpack, Rollup as the default stack.</li>
              <li>Node.js, single-threaded, plugin-heavy architectures.</li>
              <li>Designed for correctness and flexibility, not raw speed.</li>
            </ul>
          </section>
          <section>
            <img
              src="https://babeljs.io/img/babel.svg"
              alt="Babel logo"
              style="max-width: 140px; height: auto; margin: 0 0 1rem 0;"
            />
            <ul>
              <li><strong>2014</strong>: launched as <em>6to5</em>, compiling ES6 down to ES5 so new syntax could run in old browsers.</li>
              <li><strong>2015</strong>: renamed <strong>Babel</strong> and repositioned as a general JS compiler platform with presets, plugins, and AST tooling.</li>
              <li><strong>2015–2017</strong>: became the backbone of “modern JS” stacks, handling ESNext, JSX, and later TypeScript/Flow in almost every webpack-based project.</li>
              <li><strong>Today</strong>: still the most feature-complete and extensible transpiler when you need full spec coverage or custom transforms, even as faster Rust/Go tools appear.</li>
            </ul>
          </section>
          <section>
            <img
              src="./long-waiting-webpack.png"
              alt="Me when I wait for Webpack to build meme"
              style="max-width: 80%; height: auto;"
            />
          </section>
          <section>
            <div style="display: flex; gap: 2rem; align-items: center; justify-content: center; margin: 0 0 1.5rem 0;">
              <img
                src="https://webpack.js.org/site-logo.c0e60df418e04f58.svg"
                alt="Webpack logo"
                style="
                  max-width: 220px;
                  height: auto;
                  padding: 0.75rem 1.75rem;
                  border-radius: 999px;
                  background: rgba(5, 15, 30, 0.9);
                  box-shadow: 0 12px 30px rgba(0, 0, 0, 0.6);
                "
              />
            </div>
            <ul>
              <li><strong>2014</strong>: introduced as a JS module bundler that turns <code>require</code>/<code>import</code> graphs into browser-ready bundles.</li>
              <li><strong>2015–2016</strong>: rode the React and SPA wave; “everything is a module” plus dev server and HMR made it the default for complex front‑ends.</li>
              <li><strong>2016–2017</strong>: loader/plugin ecosystem exploded (babel-loader, style-loader, file-loader, etc.); many CLIs embed webpack under the hood.</li>
              <li><strong>Today</strong>: still entrenched in large and long‑lived apps, but known for slow cold builds, sluggish HMR, and configuration complexity at scale.</li>
            </ul>
          </section>
          <section>
            <h3>ESLint</h3>
            <ul>
              <li><strong>2013</strong>: created by Nicholas Zakas as a configurable, plugin‑based alternative to JSLint/JSHint where every rule is just JS over an AST.</li>
              <li><strong>2014–2016</strong>: plugin configs (Airbnb, StandardJS, framework presets) turned ESLint into the hub for code style and best‑practice rules; it joined the JS/OpenJS Foundation as core infra.</li>
              <li><strong>Today</strong>: virtually every serious JS/TS project wires ESLint into editors and CI; it remains the de‑facto standard linter across the ecosystem.</li>
            </ul>
          </section>
          <section>
            <h3>Prettier</h3>
            <ul>
              <li><strong>2016–2017</strong>: launched as an opinionated formatter that parses code to an AST and prints it back with fixed layout rules to end style bikeshedding.</li>
              <li><strong>2017–2020s</strong>: rapidly adopted in editors and CLIs, expanded beyond JS to TS, CSS, JSON, GraphQL, Markdown, HTML.</li>
              <li><strong>Today</strong>: common pattern is ESLint for correctness and Prettier for layout, often using <code>eslint-config-prettier</code>/<code>eslint-plugin-prettier</code> to keep them in sync.</li>
            </ul>
          </section>
        </section>

        <!-- 6. Rust transpilers & compilers -->
        <section>
          <section>
            <h2>Rust Transpilers &amp; Compilers</h2>
            <ul>
              <li>Rust replaces Babel/tsc at the “compile JS/TS” layer with much faster engines.</li>
              <li>Two key players today: <strong>SWC</strong> and <strong>Oxc</strong>.</li>
            </ul>
          </section>

          <section>
            <div class="tool-heading">
              <img
                src="https://swc.rs/logo.png"
                alt="SWC logo"
                style="max-width: 120px; height: auto; margin: 0;"
              />
              <h3>SWC: What It Is</h3>
            </div>
            <ul>
              <li><strong>Speedy Web Compiler</strong>: “Babel written in Rust”, an embeddable JS/TS compiler core.</li>
              <li><strong>Role</strong>: parses JS/TS/JSX, runs built‑in transforms, and emits JS + source maps; exposed to Node via native bindings.</li>
              <li><strong>Goal</strong>: be the low-level engine used by frameworks and bundlers rather than a CLI you use directly.</li>
              <li><strong>Performance</strong>: commonly 10–20× faster than Babel in real projects, even more in microbenchmarks.</li>
            </ul>
          </section>

          <section>
            <h3>SWC in the Ecosystem</h3>
            <ul>
              <li><strong>Next.js</strong>: SWC is the default compiler and minifier, replacing Babel + Terser in most apps.</li>
              <li><strong>Deno</strong>: uses SWC internally for JS/TS compilation.</li>
              <li><strong>Parcel 2, Rspack/Rsbuild, Jest</strong>: SWC powers fast transforms via <code>@swc/core</code> and <code>@swc/jest</code>.</li>
              <li><strong>Usage pattern</strong>: teams often run <code>tsc --noEmit</code> for type checking and SWC for emitting JS.</li>
              <li><strong>Limits</strong>: no built-in type checking; plugin ecosystem is smaller than Babel’s.</li>
            </ul>
          </section>

          <section>
            <h3>Oxc: The Next Rust Engine</h3>
            <ul>
              <li><strong>Oxc project</strong>: a newer Rust-based compiler platform, developed to push beyond SWC in speed and ergonomics.</li>
              <li><strong>Goals</strong>: provide a very fast JS/TS transformer, isolated <code>.d.ts</code> emit, and minification, acting as the core for future tools (e.g. VoidZero’s stack, dprint, Biome integrations).</li>
              <li><strong>Design</strong>: smaller packages, lower memory usage, and APIs designed from day one to support modern React/TS workflows.</li>
            </ul>
          </section>

          <section>
            <h3>Babel vs SWC vs Oxc</h3>
            <p>Rough transform throughput, normalized to Babel = 1×.</p>
            <div style="max-width: 620px; margin: 1.5rem auto;">
              <div style="margin-bottom: 0.5rem; color: #0a3d5f; font-weight: 600;">Babel (baseline)</div>
              <div style="background: rgba(255,255,255,0.08); border-radius: 999px; overflow: hidden; margin-bottom: 1rem;">
                <div style="width: 12%; background: #f97373; padding: 0.35rem 0.5rem; border-radius: 999px; text-align: right; font-size: 0.8rem;">
                  1×
                </div>
              </div>

              <div style="margin-bottom: 0.5rem; color: #0a3d5f; font-weight: 600;">SWC</div>
              <div style="background: rgba(255,255,255,0.08); border-radius: 999px; overflow: hidden; margin-bottom: 1rem;">
                <div style="width: 55%; background: #4fd1ff; padding: 0.35rem 0.5rem; border-radius: 999px; text-align: right; font-size: 0.8rem;">
                  ~10–20×
                </div>
              </div>

              <div style="margin-bottom: 0.5rem; color: #0a3d5f; font-weight: 600;">Oxc</div>
              <div style="background: rgba(255,255,255,0.08); border-radius: 999px; overflow: hidden;">
                <div style="width: 100%; background: #ff4b6a; padding: 0.35rem 0.5rem; border-radius: 999px; text-align: right; font-size: 0.8rem;">
                  ~30–50×
                </div>
              </div>
            </div>
            <p style="font-size: 0.7em; opacity: 0.9; margin-top: 0.8rem;">
              Sources (summarized): SWC “Performance Comparison of SWC and Babel”; DataStation “Benchmarking esbuild, swc, tsc, and babel for React/JSX”;<br />
              Oxc “Transformer Alpha” and bench-transformer; privatenumber’s minification-benchmarks.
            </p>
          </section>

          <section>
            <h3>Rust Compilers: Trade-offs</h3>
            <ul>
              <li><strong>No type checking</strong>: SWC and Oxc don’t replace <code>tsc</code>; you still need a type-checking step.</li>
              <li><strong>Plugin ecosystems</strong>: smaller and less approachable than Babel’s JS plugins, though growing and often enough for common use cases.</li>
              <li><strong>Native binaries</strong>: bring speed, but also platform quirks (arch/libc issues in CI or containers).</li>
              <li><strong>Benchmarks</strong>: many results are vendor-run; they’re reproducible but should be treated as indicative, not absolute.</li>
            </ul>
          </section>
        </section>

        <!-- 7. Rust bundlers & dev servers -->
        <section>
          <section>
            <h2>Rust Bundlers &amp; Dev Servers</h2>
            <ul>
              <li>Rust bundlers aim to replace webpack/Rollup at the “bundle &amp; serve” layer.</li>
              <li>Three main flavors: <strong>Rspack</strong> (Webpack-native), <strong>Rolldown</strong> (Vite-native), and <strong>Turbopack</strong> (Next-native).</li>
            </ul>
          </section>

          <section>
            <h3>Rspack: What It Is</h3>
            <ul>
              <li>Rust-powered bundler from ByteDance that keeps the <strong>Webpack mental model</strong> and ecosystem.</li>
              <li>Exposes a webpack-like config surface (entry, loaders, plugins, optimization).</li>
              <li>Implements familiar webpack features like HMR, code splitting, and asset handling.</li>
            </ul>
          </section>

          <section>
            <h3>Rspack: Performance &amp; Fit</h3>
            <ul>
              <li>In React benchmarks, Rspack with SWC has been roughly <strong>4× faster than webpack(esbuild)</strong> and <strong>~6× faster than Rollup(esbuild)</strong> on synthetic large apps.</li>
              <li>Rspack’s own 50k-modules benchmark shows dev cold start around <strong>3.8 s vs 31–42 s</strong> for webpack, prod builds around <strong>22 s vs 75–160 s</strong> on the same configs.</li>
              <li>If you run a big webpack-based SPA with lots of loaders/plugins, <strong>Rspack is your best bet</strong> for a drop-in performance upgrade.</li>
            </ul>
          </section>

          <section>
            <h3>Rolldown: Why Vite Is Migrating</h3>
            <ul>
              <li><strong>Unification</strong>: Vite today uses esbuild for dependency pre-bundling and Rollup for production; Rolldown’s goal is a single Rust bundler that handles both.</li>
              <li><strong>Compatibility</strong>: supports a Rollup/Vite-compatible plugin API so most existing Vite/Rollup plugins can be reused.</li>
              <li><strong>Positioning</strong>: designed as Vite’s long-term default bundler and a drop-in Rollup replacement.</li>
            </ul>
          </section>

          <section>
            <h3>Rolldown: Features &amp; Extras</h3>
            <ul>
              <li>Built-in TS/JSX/syntax lowering, Node-style resolution, ESM/CJS interop, <code>define</code>/<code>inject</code>, experimental CSS bundling and minification.</li>
              <li>Reports roughly <strong>10–30× faster than Rollup</strong> on comparable workloads, with a WASM build that outperforms esbuild’s.</li>
              <li>Case studies (e.g. PLAID) show Rollup+Terser → Rolldown+Oxc cutting build times from ~1150 ms to ~40 ms (≈97% faster).</li>
            </ul>
          </section>

          <section>
            <h3>Turbopack: Next-native Bundler</h3>
            <ul>
              <li>Successor to webpack from the same author, rewritten in Rust and built specifically around Next.js’ needs.</li>
              <li>Acts as a Next-aware bundler: its graph and invalidation model understand the app router, layouts, server/client components, and multiple runtimes (browser, Node, Edge).</li>
              <li>Default dev bundler for modern Next.js app router projects; production builds may still fall back to webpack while feature parity evolves.</li>
            </ul>
          </section>

          <section>
            <h3>Turbopack: Dev Experience</h3>
            <ul>
              <li>Vercel’s benchmarks show cold start on large Next apps dropping from ~35 s (webpack) to ~2 s with Turbopack.</li>
              <li>HMR updates on huge projects can be up to hundreds of times faster than webpack in vendor benchmarks.</li>
              <li>Instead of layering Next.js on top of a generic bundler, Turbopack bakes Next’s assumptions into the bundler and uses Rust to make incremental updates feel instant.</li>
            </ul>
          </section>

          <section>
            <h3>Rust Bundlers: How to Choose</h3>
            <ul>
              <li><strong>Still on webpack</strong>: big webpack SPA with lots of loaders/plugins → <strong>Rspack</strong> is your best bet.</li>
              <li><strong>On Vite</strong>: stay put—<strong>Rolldown</strong> is being built as Vite’s native bundler, and Evan + the VoidZero team will smooth the migration.</li>
              <li><strong>On Next.js for work</strong>: Next 16 already defaults to <strong>Turbopack</strong> for dev. Enjoy the speed, and keep some Claude Code or Codex budget handy for sharp edges.</li>
              <li><strong>Benchmark your own app</strong>: published numbers disagree on exact factors; real gains depend heavily on your project shape and config.</li>
            </ul>
          </section>
        </section>

        <!-- 8. Rust linters & formatters -->
        <section>
          <section>
            <h2>Rust Linters &amp; Formatters</h2>
            <ul>
              <li>Rust tools aiming to replace the ESLint + Prettier combo with faster, more integrated workflows.</li>
              <li>Two important efforts: <strong>Biome</strong> as an all‑in‑one tool, and <strong>Oxc</strong> as the engine behind future lint/format tooling.</li>
            </ul>
          </section>

          <section>
            <h3>Biome: Rome Reborn in Rust</h3>
            <ul>
              <li><strong>Origin</strong>: fork and rewrite of the Rome project in Rust, with a singular focus on speed and reliability.</li>
              <li><strong>Performance</strong>: Biome’s own “Prettier challenge” benchmarks show it beating Prettier on both speed and resource usage on real‑world codebases.</li>
              <li><strong>Scope</strong>: single binary that formats, lints, and organizes imports for JS/TS (and more) with one config instead of “ESLint + Prettier + plugins”.</li>
              <li><strong>Framework support</strong>: recent releases (e.g. Biome v2.3) added first‑class support for Vue, Astro, and Svelte on top of React/TS/Node.</li>
              <li><strong>Recommendation</strong>: if you’ve never tried it, running Biome once over an existing project is an easy way to feel what a Rust‑powered lint+format pipeline can do.</li>
            </ul>
          </section>

          <section>
            <h3>Oxc: Engine for Future Linters &amp; Formatters</h3>
            <ul>
              <li><strong>Oxc</strong> is a Rust compiler/tooling platform that also powers experimental linters and formatters (for example, <em>oxlint</em> and Oxc‑based formatters).</li>
              <li><strong>Design goals</strong>: very fast parsing and transforms, small binary size, and modern JS/TS support suitable for editor‑on‑save workflows.</li>
              <li><strong>Benchmarks</strong>: Oxc‑based tools often show tens‑of‑times speedups over Babel/ESLint/Prettier stacks on transform and minification workloads.</li>
              <li><strong>Role</strong>: think of Oxc as the Rust “engine room” that future lint/format tools (including Biome integrations) can build on.</li>
            </ul>
          </section>

          <section>
            <h3>Rust Linters &amp; Formatters: Where They Shine</h3>
            <ul>
              <li>Running lint + format on every save or pre‑commit without making editors feel sluggish.</li>
              <li>Large monorepos where ESLint + Prettier currently dominate CI time.</li>
              <li>Teams that want “one tool, one config” instead of wiring ESLint rules and Prettier plugins together by hand.</li>
              <li>But: if you rely heavily on niche ESLint rules or plugins, you may still need ESLint in the loop for now.</li>
            </ul>
          </section>
        </section>

        <!-- 9. Fast tooling in the AI era -->
        <section>
          <section>
            <h2>What Does Fast Tooling Mean in the AI Era?</h2>
            <p>Or: how many extra “you are absolutely right”s can you get per day?</p>
          </section>
          <section>
            <img
              src="./you-are-absolutly-right.png"
              alt="Claude 'you're absolutely right' meme"
              style="max-width: 420px; height: auto; margin: 2rem auto 0; display: block;"
            />
            <p style="margin-top: 1.2rem; font-size: 0.95em;">
              We call this the <strong>“You Are Absolutely Right” Index</strong> – a tongue-in-cheek way to measure how often your build system lets your AI pair tell you that you’re right.
            </p>
          </section>
          <section>
            <h3>Setup: One Task Loop</h3>
            <ul>
              <li>You ask an AI assistant to do something on your project.</li>
              <li>Roughly every task takes about <strong>10 minutes of AI work</strong>.</li>
              <li>After each task, you run lint + build to check it.</li>
            </ul>
<pre><code class="language-javascript" data-trim>
// Legacy loop (webpack-era)
10 min AI work
+ 4 min build (webpack)
= 14 min per validation

// Rust tooling loop
10 min AI work
+ ~0.7 min build (Rust tools)
= ~10.7 min per validation
</code></pre>
          </section>
          <section>
            <h3>Per 8-Hour Day: How Many “You’re Absolutely Right”s?</h3>
            <p>Assume an 8-hour day (480 minutes).</p>
            <div style="display: flex; gap: 2rem; justify-content: center; margin-top: 1rem; font-size: 0.95em;">
              <div>
                <p style="font-weight: 600; margin-bottom: 0.4rem;">Legacy stack (webpack)</p>
<pre><code class="language-javascript" data-trim>
480 / 14 ≈ 34
validations / day
</code></pre>
              </div>
              <div>
                <p style="font-weight: 600; margin-bottom: 0.4rem;">Rust stack (SWC/Rspack/Rolldown/Biome)</p>
<pre><code class="language-javascript" data-trim>
480 / 10.8 ≈ 44
validations / day
</code></pre>
              </div>
            </div>
            <ul>
              <li>Difference: roughly <strong>10 extra “you are absolutely right”s per day</strong> from your AI pair.</li>
              <li>Run three tasks in parallel and you’re looking at ~30 extra micro‑dopamine hits of AI validation.</li>
            </ul>
          </section>
        </section>

        <!-- 6. Shared architecture patterns -->
        <section>
          <section>
            <h2>Why Rust Fits JS Tooling</h2>
            <ul>
              <li>Memory safety without GC pauses.</li>
              <li>Predictable performance and fine-grained control over resources.</li>
              <li>Easy to exploit multi-core CPUs for parallel work.</li>
            </ul>
          </section>
          <section>
            <h3>Architecture Patterns</h3>
            <ul>
              <li>Parse once, reuse AST across multiple tools.</li>
              <li>Parallel transforms across files and modules.</li>
              <li>Incremental builds and aggressive caching for dev and CI.</li>
              <li>Smaller binaries and stable long-running processes.</li>
            </ul>
          </section>
        </section>

        <!-- 7. Limitations and tradeoffs -->
        <section>
          <section>
            <h2>Limitations and Tradeoffs</h2>
            <ul>
              <li>Plugin ecosystems still catching up with legacy tools.</li>
              <li>Incomplete coverage of bleeding-edge proposals and niche transforms.</li>
              <li>Migration costs: configs, build scripts, CI pipelines.</li>
              <li>Type checking still relies on tsc or language servers.</li>
            </ul>
          </section>
          <section>
            <h3>When Not to Migrate Yet</h3>
            <ul>
              <li>Stable, medium-size apps with acceptable build times.</li>
              <li>Heavy reliance on custom Babel or Webpack plugins.</li>
              <li>Teams without capacity to rework infra and CI.</li>
            </ul>
          </section>
        </section>

        <!-- 8. Practical migration paths -->
        <section>
          <section>
            <h2>Practical Migration Paths</h2>
            <ul>
              <li>Step 1: swap Babel for SWC where possible.</li>
              <li>Step 2: introduce Biome for lint/format in a subset of the repo.</li>
              <li>Step 3: adopt Turborepo or similar for monorepo and CI performance.</li>
              <li>Step 4: experiment with Turbopack or Vite + Rolldown on new services.</li>
            </ul>
          </section>
          <section>
            <h3>Measuring Impact</h3>
            <ul>
              <li>Track cold start, HMR latency, and full build time.</li>
              <li>Measure CI duration and flakiness before and after.</li>
              <li>Monitor developer satisfaction and iteration speed.</li>
            </ul>
          </section>
        </section>

        <!-- 9. Closing -->
        <section>
          <h2>Rust Tooling and the Future of JS</h2>
          <ul>
            <li>From &quot;JS everywhere&quot; to &quot;Rust under the hood&quot; for tooling.</li>
            <li>Order-of-magnitude speedups unlock new workflows and scale.</li>
            <li>You do not have to write Rust to benefit from it.</li>
            <li>What matters: understanding the tradeoffs and choosing the right stack.</li>
          </ul>
        </section>
      </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/reveal.js@5.1.0/dist/reveal.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/reveal.js@5.1.0/plugin/highlight/highlight.js"></script>
    <script>
      Reveal.initialize({
        hash: true,
        slideNumber: true,
        controls: true,
        progress: true,
        plugins: [RevealHighlight],
      });
    </script>
  </body>
</html>
