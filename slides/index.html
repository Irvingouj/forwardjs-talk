<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Rust Tooling in Modern JavaScript</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <!-- Reveal.js via CDN to keep setup simple -->
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/reveal.js@5.1.0/dist/reveal.css"
    />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/reveal.js@5.1.0/dist/theme/white.css"
      id="theme"
    />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/reveal.js@5.1.0/plugin/highlight/monokai.css"
    />

    <style>
      body {
        background: radial-gradient(circle at top left, #4fd1ff 0, #0b1724 40%, #200016 100%);
      }

      .reveal {
        color: #f5f5f5;
      }

      .reveal section h1,
      .reveal section h2,
      .reveal section h3 {
        text-transform: none;
        letter-spacing: 0.03em;
      }

      .reveal section h1 {
        color: #ff4b6a;
        text-shadow: 0 0 18px rgba(255, 75, 106, 0.5);
      }

      .reveal section h2,
      .reveal section h3 {
        color: #4fd1ff;
        text-shadow: 0 0 14px rgba(79, 209, 255, 0.4);
      }

      .reveal p,
      .reveal li {
        color: #0a3d5f;
      }

      .reveal a {
        color: #ff4b6a;
      }

      .reveal img {
        filter: drop-shadow(0 6px 18px rgba(0, 0, 0, 0.6));
      }

      .hero-blackhole {
        position: relative;
        width: 100%;
        max-width: 900px;
        height: 380px;
        margin: 2.5rem auto 0;
      }

      .code-row {
        display: flex;
        gap: 1.5rem;
        justify-content: center;
        align-items: flex-start;
        margin-bottom: 1.2rem;
      }

      .code-row pre {
        flex: 1 1 0;
      }

      .tool-heading {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 1rem;
        margin-bottom: 1rem;
      }


      .reveal pre {
        box-shadow: 0 14px 35px rgba(0, 0, 0, 0.55);
        border-radius: 14px;
        overflow: auto;
        max-height: 60vh;
        background: #050b16;
        max-width: 80%;
        margin: 1rem auto;
      }

      .reveal pre code {
        font-size: 0.75em;
        line-height: 1.4;
        text-shadow: none;
        padding: 1rem 1.25rem;
        display: block;
      }

      .tooling-line {
        font-size: 1.05rem;
        margin: 0.6rem 0;
        color: #0a3d5f;
      }

      .tooling-kind {
        color: #ff4b6a;
        font-weight: 600;
      }

      .hero-blackhole-core {
        position: absolute;
        top: 50%;
        left: 50%;
        width: 220px;
        height: 220px;
        border-radius: 50%;
        transform: translate(-50%, -50%);
        background: radial-gradient(circle, #000 0, #050518 35%, rgba(0, 0, 0, 0) 75%);
        box-shadow:
          0 0 40px rgba(0, 0, 0, 0.9),
          0 0 80px rgba(79, 209, 255, 0.8),
          0 0 120px rgba(255, 75, 106, 0.6);
      }

      .hero-logo {
        position: absolute;
        width: 80px;
        height: auto;
        top: 50%;
        left: 50%;
        transform-origin: center center;
      }

      .hero-logo--swc {
        animation: hero-orbit-swc 38s linear infinite;
      }

      .hero-logo--babel {
        animation: hero-orbit-babel 26s linear infinite reverse;
      }

      .hero-logo--webpack {
        animation: hero-orbit-webpack 44s linear infinite;
      }

      .hero-logo--rollup {
        animation: hero-orbit-rollup 32s linear infinite reverse;
      }

      .hero-logo--vite {
        animation: hero-orbit-vite 30s linear infinite;
      }

      .hero-logo--turbo {
        animation: hero-orbit-turbo 52s linear infinite reverse;
      }

      .hero-logo--rolldown {
        animation: hero-orbit-rolldown 48s linear infinite;
      }

      .hero-logo--oxc {
        animation: hero-orbit-oxc 34s linear infinite reverse;
      }

      .hero-logo--biome {
        animation: hero-orbit-biome 40s linear infinite;
      }

      @keyframes hero-orbit-swc {
        from {
          transform: translate(-50%, -50%) rotate(0deg) translateX(320px);
        }
        to {
          transform: translate(-50%, -50%) rotate(360deg) translateX(320px);
        }
      }

      @keyframes hero-orbit-babel {
        from {
          transform: translate(-50%, -50%) rotate(0deg) translateX(260px);
        }
        to {
          transform: translate(-50%, -50%) rotate(360deg) translateX(260px);
        }
      }

      @keyframes hero-orbit-webpack {
        from {
          transform: translate(-50%, -50%) rotate(0deg) translateX(300px);
        }
        to {
          transform: translate(-50%, -50%) rotate(360deg) translateX(300px);
        }
      }

      @keyframes hero-orbit-rollup {
        from {
          transform: translate(-50%, -50%) rotate(0deg) translateX(220px);
        }
        to {
          transform: translate(-50%, -50%) rotate(360deg) translateX(220px);
        }
      }

      @keyframes hero-orbit-vite {
        from {
          transform: translate(-50%, -50%) rotate(0deg) translateX(280px);
        }
        to {
          transform: translate(-50%, -50%) rotate(360deg) translateX(280px);
        }
      }

      @keyframes hero-orbit-turbo {
        from {
          transform: translate(-50%, -50%) rotate(0deg) translateX(340px);
        }
        to {
          transform: translate(-50%, -50%) rotate(360deg) translateX(340px);
        }
      }

      @keyframes hero-orbit-rolldown {
        from {
          transform: translate(-50%, -50%) rotate(0deg) translateX(240px);
        }
        to {
          transform: translate(-50%, -50%) rotate(360deg) translateX(240px);
        }
      }

      @keyframes hero-orbit-oxc {
        from {
          transform: translate(-50%, -50%) rotate(0deg) translateX(200px);
        }
        to {
          transform: translate(-50%, -50%) rotate(360deg) translateX(200px);
        }
      }

      @keyframes hero-orbit-biome {
        from {
          transform: translate(-50%, -50%) rotate(0deg) translateX(260px);
        }
        to {
          transform: translate(-50%, -50%) rotate(360deg) translateX(260px);
        }
      }

      @media (max-width: 768px) {
        .hero-blackhole {
          height: 260px;
        }

        .hero-blackhole-core {
          width: 160px;
          height: 160px;
        }

        .hero-logo {
          width: 56px;
        }
      }
    </style>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <!-- 1. Intro -->
        <section>
          <div class="hero-blackhole">
            <div class="hero-blackhole-core"></div>
            <img
              class="hero-logo hero-logo--swc"
              src="https://swc.rs/logo.png"
              alt="SWC logo"
            />
            <img
              class="hero-logo hero-logo--babel"
              src="https://babeljs.io/img/babel.svg"
              alt="Babel logo"
            />
            <img
              class="hero-logo hero-logo--webpack"
              src="https://webpack.js.org/site-logo.c0e60df418e04f58.svg"
              alt="Webpack logo"
            />
            <img
              class="hero-logo hero-logo--rollup"
              src="https://rollupjs.org/rollup-logo.svg"
              alt="Rollup logo"
            />
            <img
              class="hero-logo hero-logo--vite"
              src="https://vitejs.dev/logo.svg"
              alt="Vite logo"
            />
            <img
              class="hero-logo hero-logo--turbo"
              src="https://turborepo.com/images/docs/repo/repo-hero-logo-dark.svg"
              alt="Turborepo logo"
            />
            <img
              class="hero-logo hero-logo--rolldown"
              src="https://rolldown.rs/rolldown-round.svg"
              alt="Rolldown logo"
            />
            <img
              class="hero-logo hero-logo--oxc"
              src="https://cdn.jsdelivr.net/gh/oxc-project/oxc-assets/round.svg"
              alt="Oxc logo"
            />
            <img
              class="hero-logo hero-logo--biome"
              src="https://biomejs.dev/_astro/logo-dark-transparent.Bwi2A1en.svg"
              alt="Biome logo"
            />
          </div>
        </section>

        <!-- 2. Title -->
        <section>
          <h1>Oxidize JavaScript Toolchain</h1>
        </section>

        <!-- 3. What is tooling? -->
        <section>
          <section>
            <h2>What Do We Mean by “Tooling”?</h2>
            <p class="tooling-line">
              <span class="tooling-kind">Transpilers</span> reshape source code to run on specific runtimes or browsers.
            </p>
            <p class="tooling-line">
              <span class="tooling-kind">Bundlers</span> stitch many modules and assets into a few deployable bundles.
            </p>
            <p class="tooling-line">
              <span class="tooling-kind">Linters</span> enforce correctness, catch bugs, and guide best practices.
            </p>
            <p class="tooling-line">
              <span class="tooling-kind">Formatters</span> keep code visually consistent and easy to read.
            </p>
          </section>
          <section>
            <h3>Transpilers: Modern JS to Compatible JS</h3>
            <p>From ESNext/TS/JSX to browser-compatible JavaScript.</p>
<pre><code class="language-javascript" data-trim>
// Source (ESNext)
const greeting = `Hello, ${user.name || "friend"}!`;
</code></pre>
          </section>
          <section>
            <h3>Transpilers: Modern JS to Compatible JS (cont.)</h3>
            <p>What the transpiled output might look like.</p>
<pre><code class="language-javascript" data-trim>
// Output (ES5-ish, simplified)
var name = user && user.name ? user.name : "friend";
var greeting = "Hello, " + name + "!";
</code></pre>
          </section>
          <section>
            <h3>Transpilers: JSX to JavaScript</h3>
            <p>Turn JSX syntax into plain JavaScript function calls.</p>
<pre><code class="language-javascript" data-trim>
// Source (JSX)
function Button() {
  return &lt;button className="primary"&gt;Click me&lt;/button&gt;;
}
</code></pre>
<pre><code class="language-javascript" data-trim>
// Output (JavaScript)
function Button() {
  return React.createElement(
    "button",
    { className: "primary" },
    "Click me",
  );
}
</code></pre>
            <p style="margin-top: 1.2rem; font-size: 0.9em;">
              Live demo idea: try a Rust-based transpiler playground such as
              <a href="https://swc.rs/playground" target="_blank" rel="noreferrer">swc.rs/playground</a>.
            </p>
          </section>
          <section>
            <h3>Bundlers: Bundle for the Browser</h3>
            <p>Take multiple modules and ship a single browser-ready bundle.</p>
            <div class="code-row">
<pre><code class="language-javascript" data-trim>
// src/index.js
import { add } from "./math.js";

console.log(add(1, 2));
</code></pre>
<pre><code class="language-javascript" data-trim>
// src/math.js
export function add(a, b) {
  return a + b;
}
</code></pre>
            </div>
<pre><code class="language-javascript" data-trim>
// dist/main.js (simplified bundle)
(function () {
  function add(a, b) {
    return a + b;
  }

  console.log(add(1, 2));
})();
</code></pre>
          </section>
          <section>
            <h3>Bundlers: Resolve Node-style Imports</h3>
            <p>Turn <code>import</code> from packages into code the browser can actually run.</p>
<pre><code class="language-javascript" data-trim>
// src/index.js (what you write)
import _ from "lodash";

console.log(_.camelCase("hello world"));
</code></pre>
          </section>
          <section>
            <h3>Bundlers: Resolve Node-style Imports (cont.)</h3>
<pre><code class="language-javascript" data-trim>
// dist/bundle.js (highly simplified)
(function (modules) {
  function __webpack_require__(id) {
    const module = { exports: {} };
    modules[id](module, module.exports, __webpack_require__);
    return module.exports;
  }

  __webpack_require__("./src/index.js");
})({
  "./src/index.js"(module, exports, __webpack_require__) {
    const _ = __webpack_require__(
      "./node_modules/lodash/lodash.js",
    );

    console.log(_.camelCase("hello world"));
  },

  "./node_modules/lodash/lodash.js"(module, exports) {
    // lodash implementation here...
  },
});
</code></pre>
          </section>
          <section>
            <h3>Linters: Catch Bugs Early</h3>
            <p>Static checks that prevent common mistakes.</p>
<pre><code class="language-javascript" data-trim>
// Before (ESLint screaming)
function greet(name) {
  message = "Hi " + name;     // ESLint: 'message' is not defined
  if (name == "admin") {      // ESLint: Expected '===' and strict equality
    console.log("Welcome");   // ESLint: Unexpected console statement
  }
}
</code></pre>
<pre><code class="language-javascript" data-trim>
// After (ESLint fixes)
function greet(name) {
  const message = `Hi ${name}`;
  if (name === "admin") {
    return "Welcome back!";
  }
  return message;
}
</code></pre>
          </section>
          <section>
            <h3>Formatters: Make Code Consistent</h3>
            <p>Automatic formatting so style debates disappear.</p>
<pre><code class="language-javascript" data-trim>
// Before
const query={limit:10,offset:0, filters:[ "rust","tooling" ] }
function load(){return fetch("/api/search",{
method:"POST",body:JSON.stringify(query)})}
</code></pre>
<pre><code class="language-javascript" data-trim>
// After (formatted)
const query = {
  limit: 10,
  offset: 0,
  filters: ["rust", "tooling"],
};

function load() {
  return fetch("/api/search", {
    method: "POST",
    body: JSON.stringify(query),
  });
}
</code></pre>
          </section>
        </section>

        <!-- 4. Why Rust tooling -->
        <section>
          <section>
            <h2>Why Do We Need Rust Tooling?</h2>
          </section>
          <section>
            <h2>Why Do We Need Rust Tooling?</h2>
            <img
              src="./rewrite-everything-in-rust.png"
              alt="Rewrite it in Rust bell-curve meme"
              style="max-width: 380px; height: auto; margin: 2rem auto 0;"
            />
            <p style="margin-top: 1.2rem; font-size: 0.9em; opacity: 0.9;">
              Let&apos;s just rewrite everything in Rust!
            </p>
          </section>
          <section>
            <h2>Why Do We Actually Need Rust Tooling?</h2>
            <ul>
              <li>Faster.</li>
              <li class="fragment">Both development time for better developer experience and cheaper CI cost.</li>
              <li class="fragment">Old tools can&apos;t keep up with today&apos;s scale and needs.</li>
            </ul>
          </section>
        </section>

        <!-- 5. Old World: JS-written tooling -->
        <section>
          <section>
            <h2>The Old World: JS Tooling</h2>
            <ul>
              <li>Babel, Webpack, Rollup as the default stack.</li>
              <li>Node.js, single-threaded, plugin-heavy architectures.</li>
              <li>Designed for correctness and flexibility, not raw speed.</li>
            </ul>
          </section>
          <section>
            <img
              src="https://babeljs.io/img/babel.svg"
              alt="Babel logo"
              style="max-width: 140px; height: auto; margin: 0 0 1rem 0;"
            />
            <ul>
              <li><strong>2014 → 2015</strong>: from <em>6to5</em> to <strong>Babel</strong>, making new JS & JSX run everywhere.</li>
              <li><strong>Backbone of modern JS</strong>: powered most webpack-era React/SPA builds.</li>
              <li><strong>Still the most flexible</strong> when you need deep AST tooling or custom transforms.</li>
            </ul>
          </section>
          <section>
            <img
              src="./long-waiting-webpack.png"
              alt="Me when I wait for Webpack to build meme"
              style="max-width: 80%; height: auto;"
            />
          </section>
          <section>
            <div style="display: flex; gap: 2rem; align-items: center; justify-content: center; margin: 0 0 1.5rem 0;">
              <img
                src="https://webpack.js.org/site-logo.c0e60df418e04f58.svg"
                alt="Webpack logo"
                style="
                  max-width: 220px;
                  height: auto;
                  padding: 0.75rem 1.75rem;
                  border-radius: 999px;
                  background: rgba(5, 15, 30, 0.9);
                  box-shadow: 0 12px 30px rgba(0, 0, 0, 0.6);
                "
              />
            </div>
            <ul>
              <li><strong>2014</strong>: turned <code>require</code>/<code>import</code> graphs into browser bundles.</li>
              <li><strong>React & SPA decade</strong>: dev server + HMR made webpack the default for big front‑ends.</li>
              <li><strong>Today</strong>: still everywhere, but infamous for slow cold builds and complex configs.</li>
            </ul>
          </section>
          <section>
            <h3>ESLint &amp; Prettier</h3>
            <ul>
              <li><strong>ESLint (2013)</strong>: configurable, plugin‑based linter that every major JS/TS style guide built on.</li>
              <li><strong>Prettier (2016)</strong>: opinionated formatter that turned “save” into “reformat and end bikeshedding”.</li>
              <li><strong>Standard combo</strong>: ESLint for correctness + Prettier for layout in almost every modern JS repo.</li>
            </ul>
          </section>
        </section>

        <!-- 6. Rust transpilers & compilers -->
        <section>
          <section>
            <h2>Rust Compilers You Actually Touch</h2>
            <ul>
              <li><strong>SWC</strong>: Babel-style JS/TS compiler rewritten in Rust, used by frameworks and bundlers.</li>
              <li><strong>Oxc</strong>: a general-purpose JS/TS tooling engine powering linters, bundlers, codemods, and more.</li>
              <li>You usually don&apos;t call either directly — you feel them through faster builds and linting.</li>
            </ul>
          </section>

          <section>
            <h3>SWC: Faster Babel Under the Hood</h3>
            <ul>
              <li>Replaces Babel/tsc emit in tools like <strong>Next.js</strong>, <strong>Rspack</strong>, <strong>Deno</strong>, <strong>Parcel</strong>, and <strong>Jest</strong>.</li>
              <li>Same mental model: parses JS/TS/JSX, runs transforms, emits browser-ready JS and source maps.</li>
              <li>Vendor benchmarks often show <strong>order-of-magnitude faster</strong> transforms than Babel once you use all your CPU cores.</li>
              <li style="margin-top: 0.7rem; font-size: 0.7em; opacity: 0.9;">
                Source: <a href="https://swc.rs" target="_blank" rel="noreferrer">swc.rs</a>,
                <a href="https://swc.rs/blog/perf-swc-vs-babel" target="_blank" rel="noreferrer">SWC vs Babel benchmark</a>.
              </li>
            </ul>
          </section>

          <section>
            <h3>How You Actually Use SWC</h3>
            <ul>
              <li>You almost never run <code>swc</code> yourself; your framework wires it in.</li>
              <li>Common pattern: keep <code>tsc --noEmit</code> (or your language server) for type-checking, let SWC handle emitting JS.</li>
              <li>If your app still uses <strong>Babel</strong> for heavy TS/JS transforms, you&apos;re likely paying a large, avoidable perf tax.</li>
            </ul>
          </section>

          <section>
            <h3><a href="https://oxc.rs/" target="_blank" rel="noreferrer">Oxc: The Tooling Engine</a></h3>
            <ul>
              <li>Built as a <strong>universal JS/TS tooling engine</strong>: parser, resolver, transformer, minifier, and more.</li>
              <li>Powers tools like <strong>Rolldown</strong> (bundling), <strong>Turborepo</strong> tracing, <strong>Nuxt</strong> plugins, <strong>Biome</strong> config loading, and <strong>Tauri</strong> codemods.</li>
            </ul>
          </section>

          <section>
            <h3>Oxc in the Wild</h3>
            <ul>
              <li><strong>Oxlint</strong> (Oxc-based linter) is used at scale by teams like <strong>Shopify</strong> on the admin console and thousands of early adopters, cutting CI time and cost.</li>
              <li>For most app developers, you&apos;ll meet Oxc <strong>indirectly</strong> through these tools rather than configuring it by hand.</li>
              <li style="margin-top: 0.7rem; font-size: 0.7em; opacity: 0.9;">
                Source: <a href="https://oxc.rs" target="_blank" rel="noreferrer">oxc.rs</a>,
                <a href="https://oxc.rs/docs/guide/projects" target="_blank" rel="noreferrer">Projects using Oxc</a>,
                <a href="https://voidzero.dev/posts/announcing-oxlint-1-stable" target="_blank" rel="noreferrer">Oxlint 1.0 announcement</a>.
              </li>
            </ul>
          </section>

          <section>
            <h3>SWC vs Oxc: Mental Model</h3>
            <ul>
              <li><strong>SWC</strong>: drop-in <em>&quot;Babel, but fast&quot;</em> compiler that makes your dev/build steps faster today.</li>
              <li><strong>Oxc</strong>: <em>&quot;tooling engine&quot;</em> that helps other tools be fast (lint, bundle, codemod, analyze).</li>
              <li>You don&apos;t have to choose one: expect <strong>SWC in your builds</strong> and <strong>Oxc inside your tooling</strong> at the same time.</li>
            </ul>
          </section>

          <!-- <section>
            <h3>Action Items for Your Stack</h3>
            <ul>
              <li>If you still run Babel for builds: prefer presets or frameworks that use <strong>SWC</strong> instead.</li>
              <li>Try <strong>Oxlint</strong> or <strong>Biome</strong> on a side branch to see how Rust-powered lint/format feels.</li>
              <li>Keep an eye on <strong>Rolldown</strong>, <strong>Rspack</strong>, and <strong>Turbopack</strong>: they&apos;re how you&apos;ll feel SWC/Oxc speed-ups without writing Rust.</li>
            </ul>
          </section> -->
        </section>

        <!-- 7. Rust bundlers & dev servers -->
        <section>
          <section>
            <h2>Rust Bundlers &amp; Dev Servers</h2>
            <ul>
              <li>Rust bundlers aim to replace webpack/Rollup at the “bundle &amp; serve” layer.</li>
              <li>Three main flavors: <strong>Rspack</strong> (Webpack-native), <strong>Rolldown</strong> (Vite-native), and <strong>Turbopack</strong> (Next-native).</li>
            </ul>
          </section>

          <section>
            <h3>Rspack: What It Is</h3>
            <ul>
              <li>Rust-powered bundler from ByteDance that keeps the <strong>Webpack mental model</strong> and ecosystem.</li>
              <li>Exposes a webpack-like config surface (entry, loaders, plugins, optimization).</li>
              <li>Implements familiar webpack features like HMR, code splitting, and asset handling.</li>
            </ul>
          </section>

          <section>
            <h3>Rspack: Performance &amp; Fit</h3>
            <ul>
              <li>On large React apps, vendor benchmarks show Rspack dev cold start and builds can be <strong>several times faster</strong> than webpack on the same configs.</li>
              <li>If you run a big webpack-based SPA with lots of loaders/plugins, <strong>Rspack is usually your best drop-in performance upgrade</strong>.</li>
              <li style="margin-top: 0.7rem; font-size: 0.7em; opacity: 0.9;">
                Source: <a href="https://v0.rspack.rs/misc/benchmark.html" target="_blank" rel="noreferrer">Rspack Benchmarks</a>.
              </li>
            </ul>
          </section>

          <section>
            <h3>Rolldown: Why Vite Is Migrating</h3>
            <ul>
              <li><strong>Unification</strong>: Vite today uses esbuild for dependency pre-bundling and Rollup for production; Rolldown’s goal is a single Rust bundler that handles both.</li>
              <li><strong>Compatibility</strong>: supports a Rollup/Vite-compatible plugin API so most existing Vite/Rollup plugins can be reused.</li>
              <li><strong>Positioning</strong>: designed as Vite’s long-term default bundler and a drop-in Rollup replacement.</li>
            </ul>
          </section>

          <section>
            <h3>Rolldown: Features &amp; Extras</h3>
            <ul>
              <li>Single Rust bundler aiming to handle both dev and build in the Vite/Rollup world.</li>
              <li>Built-in TS/JSX support, Node-style resolution, ESM/CJS interop, <code>define</code>/<code>inject</code>, and evolving CSS bundling/minification.</li>
            </ul>
          </section>

          <section>
            <h3>Rolldown: Real-World Impact</h3>
            <ul>
              <li>Vendor benchmarks report <strong>10–30× faster</strong> bundling than Rollup on many workloads.</li>
              <li>PLAID&apos;s case study: Rollup+Terser → Rolldown+Oxc cut build time from ~1150 ms to ~40 ms (≈97% faster).</li>
              <li style="margin-top: 0.7rem; font-size: 0.7em; opacity: 0.9;">
                Source: <a href="https://github.com/rolldown/benchmarks" target="_blank" rel="noreferrer">Rolldown Benchmarks</a>.
              </li>
            </ul>
          </section>

          <section>
            <h3>Turbopack: Next-native Bundler</h3>
            <ul>
              <li>Successor to webpack from the same author, rewritten in Rust and built specifically around Next.js’ needs.</li>
              <li>Acts as a Next-aware bundler: its graph and invalidation model understand the app router, layouts, server/client components, and multiple runtimes (browser, Node, Edge).</li>
              <li><strong>Next.js 16</strong> now defaults to Turbopack for development, with production builds rapidly catching up.</li>
            </ul>
          </section>

          <section>
            <h3>Turbopack: Dev Experience</h3>
            <ul>
              <li><strong>700x Faster Updates</strong>: On large apps, incremental architecture makes HMR nearly instant compared to Webpack.</li>
              <li><strong>Faster Startup</strong>: Boots up 5,000 modules in ~4s (vs Vite's ~16.6s), bundling only what's needed.</li>
              <li><strong>The Mission</strong>: Replacing Babel (17x faster) and Terser (6x faster) was just the start; Turbopack tackles the bundler bottleneck.</li>
              <li style="margin-top: 0.7rem; font-size: 0.7em; opacity: 0.9;">
                Source: <a href="https://vercel.com/blog/turbopack" target="_blank" rel="noreferrer">Vercel - Introducing Turbopack</a>.
              </li>
            </ul>
          </section>

          <section>
            <h3>Rust Bundlers: How to Choose</h3>
            <ul>
              <li><strong>Still on webpack?</strong> Big SPA with many loaders/plugins → try <strong>Rspack</strong> as a drop-in upgrade.</li>
              <li><strong>On Vite?</strong> Stay put — <strong>Rolldown</strong> will arrive under the hood as it matures.</li>
              <li><strong>On Next.js?</strong> Next 16 already defaults to <strong>Turbopack</strong> for dev — just use the current defaults.</li>
              <li><strong>Always benchmark your own app</strong>: real gains depend on your graph, plugins, and CI setup.</li>
            </ul>
          </section>
        </section>

        <!-- 8. Rust linters & formatters -->
        <section>
          <section>
            <h2>Rust Linters &amp; Formatters</h2>
            <ul>
              <li>Rust tools aiming to replace the classic <strong>ESLint + Prettier</strong> combo with faster, simpler workflows.</li>
              <li>Two big players for JS/TS today: <strong>Biome</strong> (all‑in‑one tool) and <strong>Oxc‑based</strong> linters/formatters (like Oxlint).</li>
            </ul>
          </section>

          <section>
            <h3>Biome in One Minute</h3>
            <ul>
              <li>All‑in‑one Rust tool that <strong>lints, formats, and organizes imports</strong> for JS/TS (and more) with a single config.</li>
              <li>Designed as a modern successor to ESLint + Prettier + plugins, with a much faster Rust core.</li>
              <li><strong>Prettier Challenge Winner</strong>: Achieved >96% compatibility with Prettier (v1.4.0), claiming the bounty in Nov 2023.</li>
            </ul>
          </section>

          <section>
            <h3>Biome: Performance Benchmarks</h3>
            <p style="font-size: 0.8em; opacity: 0.8; margin-bottom: 1rem;">(MacBook Pro M1, 2020)</p>
            <ul>
              <li><strong>Formatting</strong>: ~25x faster than Prettier (single-threaded ~7x).</li>
              <li><strong>Parallelism</strong>: On M1 Max (10 cores), Biome can be <strong>100x faster</strong> than Prettier.</li>
              <li><strong>Linting</strong>: ~15x faster than ESLint (even without plugins).</li>
              <li style="font-size: 0.9em; opacity: 0.9;"><em>"Biome's linter is fast, but there is room for improvements."</em></li>
            </ul>
          </section>

          <section>
            <h3>Where Biome Fits Your Stack</h3>
            <ul>
              <li>Great fit if you want <strong>one tool, one config</strong> instead of wiring ESLint + TS‑ESLint + Prettier + plugins.</li>
              <li>Works well for “lint + format on save” without your editor feeling sluggish.</li>
              <li>If you rely on niche ESLint rules, you can still keep ESLint for a subset and let Biome handle the rest.</li>
            </ul>
          </section>

          <section>
            <h3>Oxc‑Powered Linters (Oxlint)</h3>
            <ul>
              <li><strong>Oxlint</strong> is a fast linter built on the Oxc engine for JS/TS/React code.</li>
              <li>Used in production at teams like <strong>Shopify</strong> (front‑end platform on the admin console) and thousands of early adopters to cut CI time and cost.</li>
              <li>Oxc is also under the hood in tools like Rolldown, Turborepo, Nuxt, Biome, and Tauri.</li>
            </ul>
          </section>

          <section>
            <h3>Oxlint: JS Plugins Support (Preview)</h3>
            <ul>
              <li><strong>Breaking News (Oct 2025)</strong>: Oxlint now supports plugins written in JavaScript!</li>
              <li><strong>ESLint Compatibility</strong>: Runs many existing ESLint plugins without modification.</li>
              <li><strong>Hybrid Approach</strong>: Offers an alternative API for better performance while leveraging the vast JS ecosystem.</li>
              <li style="font-size: 0.9em; opacity: 0.9;"><em>"Performance is good, but it's going to get way better."</em></li>
            </ul>
          </section>

          <section>
            <h3>Rust vs ESLint/Prettier – Mental Model</h3>
            <ul>
              <li><strong>ESLint + Prettier</strong>: deeply configurable, huge plugin ecosystem, but slow on large monorepos.</li>
              <li><strong>Biome / Oxlint</strong>: fewer moving parts and smaller rule sets today, but <strong>much faster</strong> and easier to run on every save and every CI run.</li>
              <li>Realistic near‑term: keep ESLint where you must, use Rust tools for the majority of checks and formatting.</li>
            </ul>
          </section>

          <!-- <section>
            <h3>Action Items: Lint &amp; Format</h3>
            <ul>
              <li>Pick one medium‑size repo and add <strong>Biome</strong> or <strong>Oxlint</strong> alongside your existing ESLint/Prettier setup.</li>
              <li>Run both in CI for a week and compare runtime and flakiness.</li>
              <li>If the experience is good, move “format on save” and most lint rules to the Rust tool and keep only the ESLint rules/plugins you truly depend on.</li>
            </ul>
          </section> -->
        </section>

        <!-- 9. Fast tooling in the AI era -->
        <section>
          <section>
            <h2>What Does Fast Tooling Mean in the AI Era?</h2>
            <p>Or: how many extra “you are absolutely right”s can you get per day?</p>
          </section>
          <section>
            <img
              src="https://raw.githubusercontent.com/Irvingouj/forwardjs-talk/main/slides/you-are-absolutly-right.png"
              alt="Claude 'you're absolutely right' meme"
              style="max-width: 420px; height: auto; margin: 2rem auto 0; display: block;"
            />
            <p style="margin-top: 1.2rem; font-size: 0.95em;">
              We call this the <strong>“You Are Absolutely Right” Index</strong> – a tongue-in-cheek way to measure how often your build system lets your AI pair tell you that you’re right.
            </p>
          </section>
          <section>
            <h3>Setup: One Task Loop</h3>
            <ul>
              <li>You ask an AI assistant to do something on your project.</li>
              <li>Roughly every task takes about <strong>10 minutes of AI work</strong>.</li>
              <li>After each task, you run lint + build to check it.</li>
            </ul>
<pre><code class="language-javascript" data-trim>
// Legacy loop (webpack-era)
10 min AI work
+ 4 min build (webpack)
= 14 min per validation

// Rust tooling loop
10 min AI work
+ ~0.7 min build (Rust tools)
= ~10.7 min per validation
</code></pre>
          </section>
          <section>
            <h3>Per 8-Hour Day: How Many “You’re Absolutely Right”s?</h3>
            <p>Assume an 8-hour day (480 minutes).</p>
            <div style="display: flex; gap: 2rem; justify-content: center; margin-top: 1rem; font-size: 0.95em;">
              <div>
                <p style="font-weight: 600; margin-bottom: 0.4rem;">Legacy stack (webpack)</p>
<pre><code class="language-javascript" data-trim>
480 / 14 ≈ 34
validations / day
</code></pre>
              </div>
              <div>
                <p style="font-weight: 600; margin-bottom: 0.4rem;">Rust stack (SWC/Rspack/Rolldown/Biome)</p>
<pre><code class="language-javascript" data-trim>
480 / 10.8 ≈ 44
validations / day
</code></pre>
              </div>
            </div>
            <ul>
              <li>Difference: roughly <strong>10 extra “you are absolutely right”s per day</strong> from your AI pair.</li>
              <li>Run three tasks in parallel and you’re looking at ~30 extra micro‑dopamine hits of AI validation.</li>
            </ul>
          </section>
        </section>

        <!-- 6. Shared architecture patterns -->
        <section>
          <section>
            <h2>Why Rust Fits JS Tooling</h2>
            <ul>
              <li>Memory safety without GC pauses.</li>
              <li>Predictable performance and fine-grained control over resources.</li>
              <li>Easy to exploit multi-core CPUs for parallel work.</li>
            </ul>
          </section>
          <section>
            <h3>Architecture Patterns</h3>
            <ul>
              <li>Parse once, reuse AST across multiple tools.</li>
              <li>Parallel transforms across files and modules.</li>
              <li>Incremental builds and aggressive caching for dev and CI.</li>
              <li>Smaller binaries and stable long-running processes.</li>
            </ul>
          </section>
        </section>

        <!-- 7. Limitations and tradeoffs -->
        <section>
          <section>
            <h2>Limitations and Tradeoffs</h2>
            <ul>
              <li>Plugin ecosystems still catching up with legacy tools.</li>
              <li>Incomplete coverage of bleeding-edge proposals and niche transforms.</li>
              <li>Migration costs: configs, build scripts, CI pipelines.</li>
              <li>Type checking still relies on tsc or language servers.</li>
            </ul>
          </section>
          <section>
            <h3>When Not to Migrate Yet</h3>
            <ul>
              <li>Stable, medium-size apps with acceptable build times.</li>
              <li>Heavy reliance on custom Babel or Webpack plugins.</li>
              <li>Teams without capacity to rework infra and CI.</li>
            </ul>
          </section>
        </section>

        <!-- 8. Practical migration paths -->
        <section>
          <section>
            <h2>Practical Migration Paths</h2>
            <ul>
              <li>Step 1: swap Babel for SWC where possible.</li>
              <li>Step 2: introduce Biome for lint/format in a subset of the repo.</li>
              <li>Step 3: adopt Turborepo or similar for monorepo and CI performance.</li>
              <li>Step 4: experiment with Turbopack or Vite + Rolldown on new services.</li>
            </ul>
          </section>
          <section>
            <h3>Measuring Impact</h3>
            <ul>
              <li>Track cold start, HMR latency, and full build time.</li>
              <li>Measure CI duration and flakiness before and after.</li>
              <li>Monitor developer satisfaction and iteration speed.</li>
            </ul>
          </section>
        </section>

        <!-- 9. Other ecosystems -->
        <section>
          <section>
            <h2>Other Fast Tooling (Non-Rust)</h2>
            <ul>
              <li>Rust isn&apos;t the only game in town for fast JS tooling.</li>
              <li>There are mature, battle-tested tools built in <strong>Go</strong> and <strong>JavaScript</strong> too.</li>
            </ul>
          </section>

          <section>
            <h3>esbuild (Go)</h3>
            <ul>
              <li>Written in <strong>Go</strong>; one of the first &quot;blazing fast&quot; JS/TS bundlers and minifiers.</li>
              <li>Powers things like Vite&apos;s dependency pre-bundling and many existing build pipelines.</li>
              <li>Still a great choice for small tools, CLIs, and projects that don&apos;t need Rust today.</li>
            </ul>
          </section>

          <section>
            <h3>Rollup, Webpack &amp; Friends (JS)</h3>
            <ul>
              <li><strong>Rollup</strong> and <strong>webpack</strong> are JavaScript bundlers with huge ecosystems and plugin libraries.</li>
              <li>They remain the backbone of many large production apps, even as Rust and Go tools appear.</li>
              <li>Rust tools like <strong>Rolldown</strong> and <strong>Rspack</strong> are often designed as faster, mostly-compatible successors.</li>
            </ul>
          </section>

          <section>
            <h3>Takeaway</h3>
            <ul>
              <li>The &quot;fast tooling&quot; story isn&apos;t Rust vs Go vs JS; it&apos;s about choosing the right engine for your stack.</li>
              <li>Rust gives you new options, not an obligation to rewrite everything.</li>
            </ul>
          </section>
        </section>

        <!-- 10. Closing -->
        <section>
          <h2>Rust Tooling and the Future of JS</h2>
          <ul>
            <li>From &quot;JS everywhere&quot; to &quot;Rust under the hood&quot; for tooling.</li>
            <li>Order-of-magnitude speedups unlock new workflows and scale.</li>
            <li>You do not have to write Rust to benefit from it.</li>
            <li>What matters: understanding the tradeoffs and choosing the right stack.</li>
          </ul>
        </section>
      </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/reveal.js@5.1.0/dist/reveal.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/reveal.js@5.1.0/plugin/highlight/highlight.js"></script>
    <script>
      Reveal.initialize({
        hash: true,
        slideNumber: true,
        controls: true,
        progress: true,
        plugins: [RevealHighlight],
      });
    </script>
  </body>
</html>
